因为实验室假期需要写一篇关于opencv的作业 所以顺便看了一下opencv(版本3.2.0)里面关于高斯模糊的源码

## 分析函数接口

首先，在下用的是vs版本的opencv，是直接编译好给你静态库(.lib)文件的，所以当我按住`ctrl`寻找`GaussianBlur`这个函数时 只发现了其在`imgproc.hpp`里面提供给你的接口。

大概是下面这个样子的:

![高斯模糊函数接口1](https://ws1.sinaimg.cn/large/006ZO6XQly1fznmld2w3rj30zu0h2myq.jpg)

![高斯模糊函数接口2](https://ws1.sinaimg.cn/large/006ZO6XQly1fznmld2apoj31fm05g0u8.jpg)

> 该函数将源图像与指定的卷积核进行卷积。并且支持原图像直接进行滤波操作。

可以看到这个函数接口主要由四个部分组成:

1. `CV_EXPORTS_W`<br>继续往上找 可以发现这是一个宏定义<br>![宏定义1](https://ws1.sinaimg.cn/large/006ZO6XQly1fzopku1w6yj30ka01o0sm.jpg)<br>可以发现 这个宏定义是在**编译阶段**将`CV_EXPORTS`替换为了`CV_EXPORTS_W`再向上查找 会发现<br>![宏定义2](https://ws1.sinaimg.cn/large/006ZO6XQly1fzopni7pwbj310y05naaf.jpg)<br>这里又是一个宏组成的用以定义`CV_EXPORTS`的宏组，这一段其实就是类似于`if else`的结构，主要的作用机理便是**适配各类环境(操作系统)** 。从中，我们这里又分成了三个部分进行解析:
   1. `#if (defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__) && defined CVAPI_EXPORTS`<br>可以看到，这里判断了两个表达式的逻辑与(`(defined WIN32 || defined _WIN32 || defined WINCE || defined __CYGWIN__)`和`defined CVAPI_EXPORTS`)
      1. 首先，`defined`的意义在于寻找后面的字段是否已经被宏定义过。
      2. 其次，观察第一个表达式，发现`_WIN32` 在之前已经被定义过了，通过查阅[微软官方宏定义文档](https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2017)发现这个字段作用是基于编译器一个信号，表明是Windows环境下编译及运行的程序。<br>![WIN](https://ws1.sinaimg.cn/large/006ZO6XQly1fzp2jnjuwnj30m900z3yd.jpg)<br>再查找前后未定义过的字段，继而发现`WIN32`是**只要包含了 Windows.h，那么 WIN32 常量是肯定定义了**的设定，不能用于判断平台环境。<br>而`WINCE`便是判断是否为WINCE环境的程序<br>`__CYGWIN__`如果事先有了解过cygwin这个程序的话，这个应该不难看懂，也是用以判断环境的定义，而cywin则是在Windows环境下用以模拟Unix环境的软件(P.S.还是蛮好用的)
      3. 再次，观察第二个表达式，也是查找字段是否定义过，这个查了一下，发现这个宏定义是存在于opencv.dll这个文件里面的。也就是判断是否已经链接了动态库。
      4. 这样这一行便很容易懂了，目的便是判断程序环境**是否为Windows**且已经链接opencv.dll的库用以进行下一步操作。
      5. 再提一句，关于这个操作系统(环境)的判定其实还有很多，这里放一个[Qt里面关于系统判定的头文件(147行开始)](https://github.com/qt/qt/blob/4.8/src/corelib/global/qglobal.h)
   2. `# define CV_EXPORTS __declspec(dllexport)`<br>这一句涉及到的主要是dll函数导入，需要和下面最后三行联合起来看<br>`#define CV_EXPORTS`<br>第二行需要联合上面这句一同分析，首先，这个头文件内部写的都是接口，都是作者自己编写留给别人用以调用的，并且从第一点分析的结果来看，这些接口的**实现**都是放在opencv.dll文件中的，而第一行的判断便是判断你是否在最需要隐式调用，如果有，那么直接可以利用隐式调用的方法进行[**函数导出(具体__declspec也有在微软文档里写)**](https://blog.csdn.net/W_Y2010/article/details/80428067)<br>反之，如果判断事先未进行链接，那么使用的时候必然是显式调用(没错，就是配置环境的时候配置的lib文件链接，那就是显式调用了[参考此篇文章](https://wenku.baidu.com/view/f7a24236b52acfc789ebc999.html))，既然是显式调用，自然便不需要进行函数导出操作。所以将`CV_EXPORTS`字段设置为空。
   3. `elif defined __GNUC__ && __GNUC__ >= 4`<br>` define CV_EXPORTS __attribute__((visibility("default")))`<br>这两句涉及的主要有两个功能: 1. [判断是否为GCC编译环境](https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html) 2. [为全局动态库函数设置非隐藏声明](https://blog.csdn.net/mutourenzhang/article/details/47803803)<br>对于第一点，类似于分析第一条，可以知道这句的意思便是检查gcc并测试是否高于4.0.0版本(猜测与c++标准有关)
2. `void`<br>函数返回值，这里返回值为空
3. `GaussianBlur`<br>函数名，这里因为是声明所以是跟源码的函数一样，可以很快找到源码定义。
4. `()`<br>括号里面的是函数参数根据上面的说明注释，便可解读出这个函数所有参数意义:
   - `src`  这是输入图像，这个图像可以拥有任意数量的通道，这些通道是独立处理的，但深度应该是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。
   - `dst` 这是输出图像，大小与类型与src相同。
   - `ksize` 这是卷积核的大小参数(是数字desu)。其中ksize.width和ksize.height可以不同，但是它们必须是一个正奇数(或者零)，并且您不用担心卷积核内部参数问题，卷积核会根据sigma来计算。
   - `sigmaX` X方向的卷积核标准偏差。
   - `sigmaY` Y方向的高斯核标准偏差; 如果sigmaY为零，则设置为等于sigmaX，如果两个sigma都是零，则它们是从ksize.width和ksize.height计算的（详见cv :: getGaussianKernel）; 这些语义未来均有可能修改，建议指定所有ksize，sigmaX和sigmaY。
   - `borderType` 像素外推模式，请参阅cv :: BorderTypes
   - `sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur`。这里显示了函数的相关函数，是观察源码的重要提示

这样，对于函数接口的解析就算是完成了，从中我们可以得出以下几个结论：

1. 直接ctrl寻找到底是不能找到原函数代码的。
2. 找到原函数的同时也需要sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur这一些列函数辅助理解。
3. 这个函数在cv命名空间中，名称应该为`cv::GaussianBlur` 。

所以接下来第一步便是需要在源码中寻找到真正的函数实现。

## 源码解析

### 查找函数

利用grep命令，很容易便能找到这个函数，找到文件并切到这个函数定义，便可以窥见整个函数的全貌了。

![查找](https://ws1.sinaimg.cn/large/006ZO6XQly1fzraeoqon5j30xg08175j.jpg)

以下是cv::GaussianBlur函数全貌:

![](https://ws1.sinaimg.cn/large/006ZO6XQly1fzrau2yvaaj31170m90uv.jpg)
![](https://ws1.sinaimg.cn/large/006ZO6XQly1fzral0429nj310l0hr41b.jpg)

### 分析函数

分析这个函数之前，首先先要从内部关联的函数看起。2199 2393 

#### CV_INSTRUMENT_REGION()

这一行末尾没有分号，这样的类似函数的字符段有很大可能是一个宏定义变量，经查找，在private.hpp文件中有以下定义：

>  ///// General instrumentation
>  // General OpenCV region instrumentation macro 
>  #define CV_INSTRUMENT_REGION() CV_INSTRUMENT_REGION_META(cv::instr::TYPE_GENERAL, cv::instr::IMPL_PLAIN) 

经查找，这个字段主要是关于初始化以及边界类型的判断。

#### CV_OVX_RUN(true, openvx_gaussianBlur(_src, _dst, ksize, sigma1, sigma2, borderType))

这里很明显是一个被宏定义的字段，通过查找，我们能够找到其定位在`modules/core/include/opencv2/core/openvx/ovx_defs.hpp`当中

![](https://ws1.sinaimg.cn/large/006ZO6XQly1fztxw6kepgj311v0dlgmv.jpg)

按每行解析的话就是如下:

```c++
// 用于检测基于OpenVX的实现的实用程序宏
#ifdef HAVE_OPENVX
	// 如果检测到OPENVX便执行下列语句
	// 下面这两句主要作用也是标识
    #define IVX_HIDE_INFO_WARNINGS // 隐藏警告信息
    #define IVX_USE_OPENCV // 使用opencv的标识
    #include "ivx.hpp" // 将hpp文件包含进来

    #define CV_OVX_RUN(condition, func, ...)          \ // ...会被替换
    	// 这里为了给外界提供OpenVX使用表示 利用宏定义做成了一个接口
		// 而这个接口则是主要为了提供硬件层面加速用的(主要面向对象是嵌入式设计)
        if (cv::useOpenVX() && (condition) && func)   \
        {                                             \
        	// __VA_ARGS__是可变参数宏定义 用以替换上面...的内容
            return __VA_ARGS__;                       \
        }

#else
	// 否则便执行下面这条
    #define CV_OVX_RUN(condition, func, ...)
#endif // HAVE_OPENVX
```

其中`useOpenVX()`函数主要是返回一个bool类型的变量用以判断是否使用openVX用以计算。

所以`CV_OVX_RUN()`这句话便是对于嵌入式设计进行尝试性的优化操作。

#### ifdef至endif部分

```c++
//若之前有过HAVE_TEGRA_OPTIMIZATION优化选项的定义，则执行宏体中的tegra优化版函数并返回
#ifdef HAVE_TEGRA_OPTIMIZATION
	// 拷贝到临时变量(暂不知为什么要拷贝到一个临时变量里面去)
    Mat src = _src.getMat();
    Mat dst = _dst.getMat();
	
    if(sigma1 == 0 && sigma2 == 0 && tegra::useTegra() && tegra::gaussian(src, dst, ksize, borderType))
        return;
#endif
```

这里也显而易见是尝试tegra优化。

但是为什么拷贝到临时变量里也可以改变原值，这里需要进一步到Mat变量的运算符重载里面进行参考。

```C++
inline
Mat& Mat::operator = (const Mat& m)
{
    if( this != &m )
    {
        if( m.u )
            CV_XADD(&m.u->refcount, 1);
        release(); // 归零初始化
        /**
        	归零后进行基本数据共享
        */
        flags = m.flags;
        if( dims <= 2 && m.dims <= 2 )
        {
            dims = m.dims;
            rows = m.rows;
            cols = m.cols;
            step[0] = m.step[0];
            step[1] = m.step[1];
        }
        else
            copySize(m);
        data = m.data;
        datastart = m.datastart; // 共享数据头
        dataend = m.dataend; // 共享数据尾
        datalimit = m.datalimit;
        allocator = m.allocator; // 内存共享
        u = m.u;
    }
    return *this; // 返回当前对象的引用
}
```

我们可以发现在`=`重载的时候仅是进行的浅拷贝操作，意思是只将数据头数据尾进行复制，而所有数据的内存数据都是相通共享的。固仅需要一方变量更改便会联动所有对其进行过浅拷贝的变量变化。

#### 剩下部分

```c++
/**
	这里主要是针对opencl(GPU加速)无法使用的情况进行CPU版本计算
	这个IPP是一个Intel提供的开源的计算机视觉加速库，可以提供很多算法的Intel专属的多线程优化方案API，这也是为什么下面在opencl的gpu优化代码之后还又添加了利用CPU版本的filter2D的计算方案(因为有部分Intel专属的优化函数，针对APU和老式的Intel CPU(09年之前)无法进行计算，所以只能选取最普通(效率最低)的cpu filter2D计算方案执行)
	
	官网FAQ(有兴趣可以了解一下): https://software.intel.com/en-us/articles/intel-integrated-performance-primitives-intel-ipp-open-source-computer-vision-library-opencv-faq/
*/
CV_IPP_RUN(!(ocl::useOpenCL() && _dst.isUMat()), ipp_GaussianBlur( _src,  _dst,  ksize, sigma1,  sigma2, borderType));

Mat kx, ky;
/**
	这里是新建一个高斯卷积内核(后面讲)
*/
createGaussianKernels(kx, ky, type, ksize, sigma1, sigma2);

/**
	这里是针对ksize = 3 or 5的情况做了opencl优化(A卡N卡均可享受opencl优化qwq)
*/
CV_OCL_RUN(_dst.isUMat() && _src.dims() <= 2 &&
           ((ksize.width == 3 && ksize.height == 3) ||
            (ksize.width == 5 && ksize.height == 5)) &&
           (size_t)_src.rows() > ky.total() && (size_t)_src.cols() > kx.total(),
           ocl_GaussianBlur_8UC1(_src, _dst, ksize, CV_MAT_DEPTH(type), kx, ky, borderType));

/**
	这里便是利用filter2D进行操作了
*/
sepFilter2D(_src, _dst, CV_MAT_DEPTH(type), kx, ky, Point(-1,-1), 0, borderType);
```

这里在下主要解析`createGaussianKernels`与`sepFilter2D`这两个函数，主要是因为无论是`openvx_gaussianBlur`还是`ipp_GaussianBlur`以及`ocl_GaussianBlur_8UC1`都有着大量未知的API，要读懂这些API还需要大量文档查阅，在下在此就先不解析了。

所以首先先来看一下`createGaussianKernels`这个函数：

```c++
/**
	这个函数是创建高斯卷积核的函数，通过
*/
static void createGaussianKernels( Mat & kx, Mat & ky, int type, Size ksize,
                                   double sigma1, double sigma2 )
{
    int depth = CV_MAT_DEPTH(type); // 根据输入图像类型获得位深度
    if( sigma2 <= 0 )
        sigma2 = sigma1; // 非正则与sigma1相同

    // 从sigma自动检测内核大小(如果用户没有设置ksize的话)
    // 根据CV_8U来计算 大致接近7*sigma 或者 9*sigma
    // cvRound函数还内联了汇编 在下看不懂了
    if( ksize.width <= 0 && sigma1 > 0 )
        ksize.width = cvRound(sigma1*(depth == CV_8U ? 3 : 4)*2 + 1)|1;
    if( ksize.height <= 0 && sigma2 > 0 )
        ksize.height = cvRound(sigma2*(depth == CV_8U ? 3 : 4)*2 + 1)|1;

    // 这句只是为了保证卷积核的宽跟高是正奇数
    CV_Assert( ksize.width > 0 && ksize.width % 2 == 1 &&
        ksize.height > 0 && ksize.height % 2 == 1 );

    // 取最大
    sigma1 = std::max( sigma1, 0. );
    sigma2 = std::max( sigma2, 0. );

    kx = getGaussianKernel( ksize.width, sigma1, std::max(depth, CV_32F) );
    if( ksize.height == ksize.width && std::abs(sigma1 - sigma2) < DBL_EPSILON )
        // 这里 如果判断核高与核宽相等，且sigma相差很小的情况下
        // 便可以直接进行赋值操作，减少了计算量
        ky = kx;
    else
        ky = getGaussianKernel( ksize.height, sigma2, std::max(depth, CV_32F) );
}
```

从中我们还需要解析`getGaussianKernel`这个函数：

```c++
cv::Mat cv::getGaussianKernel( int n, double sigma, int ktype )
{
    // 这里定义了一个最小内核大小，
    const int SMALL_GAUSSIAN_SIZE = 7;
    static const float small_gaussian_tab[][SMALL_GAUSSIAN_SIZE] =
    {
        {1.f},
        {0.25f, 0.5f, 0.25f},
        {0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f},
        {0.03125f, 0.109375f, 0.21875f, 0.28125f, 0.21875f, 0.109375f, 0.03125f}
    };
    
    /**
    */
    const float* fixed_kernel = n % 2 == 1 && n <= SMALL_GAUSSIAN_SIZE && sigma <= 0 ? small_gaussian_tab[n>>1] : 0;
    
    CV_Assert( ktype == CV_32F || ktype == CV_64F );
    Mat kernel(n, 1, ktype);
    float* cf = kernel.ptr<float>();
    double* cd = kernel.ptr<double>();

    double sigmaX = sigma > 0 ? sigma : ((n-1)*0.5 - 1)*0.3 + 0.8;
    double scale2X = -0.5/(sigmaX*sigmaX);
    double sum = 0;

    int i;
    for( i = 0; i < n; i++ )
    {
        double x = i - (n-1)*0.5;
        double t = fixed_kernel ? (double)fixed_kernel[i] : std::exp(scale2X*x*x);
        if( ktype == CV_32F )
        {
            cf[i] = (float)t;
            sum += cf[i];
        }
        else
        {
            cd[i] = t;
            sum += cd[i];
        }
    }

    sum = 1./sum;
    for( i = 0; i < n; i++ )
    {
        if( ktype == CV_32F )
            cf[i] = (float)(cf[i]*sum);
        else
            cd[i] *= sum;
    }

    return kernel;
}
```

